;(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){

/**
 * toString ref.
 */

var toString = Object.prototype.toString;

/**
 * Return the type of `val`.
 *
 * @param {Mixed} val
 * @return {String}
 * @api public
 */

module.exports = function(val){
  switch (toString.call(val)) {
    case '[object Function]': return 'function';
    case '[object Date]': return 'date';
    case '[object RegExp]': return 'regexp';
    case '[object Arguments]': return 'arguments';
    case '[object Array]': return 'array';
  }

  if (val === null) return 'null';
  if (val === undefined) return 'undefined';
  if (val === Object(val)) return 'object';

  return typeof val;
};

},{}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
var Recap, Recorder, Storage, listeners;

listeners = require("./listeners");

Recorder = require("./recorder");

Storage = require("./storage/local");

Recap = (function() {
  /*
  */

  function Recap() {
    this._recorder = new Recorder(listeners.all());
    this._storage = new Storage(this._recorder);
  }

  /*
  */


  Recap.prototype.help = function() {
    return console.log(["start() - starts recording actions", "stop()  - stops recording actions"].join("\n"));
  };

  /*
   starts recording actions
  */


  Recap.prototype.start = function(name, description) {
    if (!name) {
      throw new Error("name must be provided");
    }
    console.log("recording user interactions");
    return this.current = this._recorder.start(name);
  };

  /*
  */


  Recap.prototype.clear = function() {
    this._recorder.clear();
    return this;
  };

  /*
  */


  Recap.prototype.remove = function(name) {
    this._recorder.remove(name);
    return this;
  };

  /*
   stops recording actions
  */


  Recap.prototype.stop = function() {
    this._recorder.stop();
    return this;
  };

  /*
  */


  Recap.prototype.saved = function() {
    return this._recorder.runners.toJSON();
  };

  /*
  */


  Recap.prototype.autoSave = function() {
    this._storage.autoSave();
    return true;
  };

  /*
  */


  Recap.prototype.save = function() {
    this._storage.save();
    return true;
  };

  return Recap;

})();

window.recap = new Recap();

window.recap.help();

},{"./listeners":8,"./recorder":9,"./storage/local":13}],3:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
var BaseListener,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

BaseListener = (function(_super) {
  __extends(BaseListener, _super);

  /*
  */


  function BaseListener() {
    BaseListener.__super__.constructor.call(this);
  }

  /*
  */


  BaseListener.prototype.start = function() {};

  /*
  */


  BaseListener.prototype.stop = function() {};

  return BaseListener;

})(require("events").EventEmitter);

module.exports = BaseListener;

},{"events":14}],4:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
var xpgen, _findCorrectElement, _findRelativeXPath, _findUniqueXPath, _findXPath;

xpgen = require("xpgen");

/*
*/


module.exports = function(element, minDepth) {
  if (minDepth == null) {
    minDepth = 2;
  }
  return _findXPath(element, minDepth);
};

/*
*/


_findXPath = function(element, minDepth) {
  var ce, rxp, uxp;
  ce = _findCorrectElement(element);
  rxp = _findRelativeXPath(ce);
  if ($(ce).attr("id")) {
    return rxp;
  }
  uxp = _findUniqueXPath(ce, rxp, minDepth);
  return uxp;
};

/*
 finds the relative xpath from the parent
*/


_findRelativeXPath = function(element) {
  var $e, attr, nodeName, parent, posibilities, xpath, _i, _j, _len, _len1, _ref;
  $e = $(element);
  nodeName = element.nodeName.toLowerCase();
  parent = $(element.parentNode);
  posibilities = [xpgen().element(nodeName).eq("@id", $e.attr("id")), xpgen().element(nodeName).index("text()[contains(.,'" + $e.text().trim() + "')]")];
  _ref = ["class", "href", "name", "value", "placeholder", "alt"];
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    attr = _ref[_i];
    posibilities.push(xpgen().element(nodeName).eq("@" + attr, $e.attr(attr)));
  }
  posibilities.push(xpgen().element(nodeName).index($e.index() + 1));
  for (_j = 0, _len1 = posibilities.length; _j < _len1; _j++) {
    xpath = posibilities[_j];
    xpath = String(xpath).substr(1);
    if (parent.xpath(xpath).length === 1) {
      return xpath;
    }
  }
};

/*
 finds the unique xpath from the document
*/


_findUniqueXPath = function(element, rxp, minDepth) {
  var $b, cp, cxpath, depth, p, xpath;
  xpath = [rxp];
  cp = element;
  $b = $(document.body);
  depth = 0;
  while (cp.parentNode) {
    depth++;
    cxpath = "//" + (p = xpath.join("/"));
    if ($(cp).attr("id") || ($b.xpath(cxpath).length === 1 && depth >= minDepth)) {
      break;
    }
    cp = cp.parentNode;
    xpath.unshift(_findRelativeXPath(cp));
  }
  return cxpath;
};

/*
*/


_findCorrectElement = function(element) {
  var cp;
  cp = element;
  while (cp) {
    if (/INPUT|BUTTON|A/.test(cp.nodeName)) {
      return cp;
    }
    cp = cp.parentNode;
  }
  return cp || element;
};

},{"xpgen":22}],5:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
var DomListener, findXPath, _ref,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

findXPath = require("./findXPath");

DomListener = (function(_super) {
  __extends(DomListener, _super);

  function DomListener() {
    this._onEvent = __bind(this._onEvent, this);
    _ref = DomListener.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  /*
  */


  DomListener.prototype.start = function() {
    var event, events, _i, _len, _results;
    events = "click".split(" ");
    _results = [];
    for (_i = 0, _len = events.length; _i < _len; _i++) {
      event = events[_i];
      _results.push(document.body.addEventListener(event, this._onEvent, true));
    }
    return _results;
  };

  /*
  */


  DomListener.prototype.stop = function() {};

  /*
  */


  DomListener.prototype._onEvent = function(event) {
    return this.emit("event", {
      listener: "dom",
      type: event.type,
      data: this._data($(event.target))
    });
  };

  /*
   finds unique attributes
  */


  DomListener.prototype._data = function($element) {
    var attrs;
    attrs = {
      xpath: findXPath($element[0])
    };
    return attrs;
  };

  return DomListener;

})(require("../base"));

module.exports = function() {
  return new DomListener();
};

},{"../base":3,"./findXPath":4}],6:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
var GroupListener, toarray,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

toarray = require("toarray");

GroupListener = (function(_super) {
  __extends(GroupListener, _super);

  /*
  */


  function GroupListener(listeners) {
    this._onEvent = __bind(this._onEvent, this);
    var listener, _i, _len, _ref;
    this._listeners = toarray(listeners);
    _ref = this._listeners;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      listener = _ref[_i];
      listener.on("event", this._onEvent);
    }
  }

  /*
  */


  GroupListener.prototype.start = function() {
    var listener, _i, _len, _ref, _results;
    _ref = this._listeners;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      listener = _ref[_i];
      _results.push(listener.start());
    }
    return _results;
  };

  /*
  */


  GroupListener.prototype.stop = function() {
    var listener, _i, _len, _ref, _results;
    _ref = this._listeners;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      listener = _ref[_i];
      _results.push(listener.stop());
    }
    return _results;
  };

  /*
  */


  GroupListener.prototype._onEvent = function(event) {
    this.emit(event.type, event.data);
    this.emit("event", event);
    return this.emit(event.listener + ".event", event);
  };

  return GroupListener;

})(require("./base"));

module.exports = function(listeners) {
  return new GroupListener(listeners);
};

},{"./base":3,"toarray":18}],7:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
var HttpListener, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

HttpListener = (function(_super) {
  __extends(HttpListener, _super);

  function HttpListener() {
    _ref = HttpListener.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  /*
  */


  HttpListener.prototype.start = function() {};

  /*
  */


  HttpListener.prototype.stop = function() {};

  return HttpListener;

})(require("./base"));

module.exports = function() {
  return new HttpListener();
};

},{"./base":3}],8:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
module.exports = {
  group: require("./group"),
  http: require("./http"),
  dom: require("./dom")
};

module.exports.all = function() {
  return module.exports.group([module.exports.http(), module.exports.dom()]);
};

},{"./dom":5,"./group":6,"./http":7}],9:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
var Recorder, Runners, events,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Runners = require("./runners");

events = require("events");

Recorder = (function(_super) {
  __extends(Recorder, _super);

  /*
  */


  function Recorder(_listener) {
    this._listener = _listener;
    this._onEvent = __bind(this._onEvent, this);
    this._listener.start();
    this.runners = new Runners();
    this._listener.on("event", this._onEvent);
  }

  /*
  */


  Recorder.prototype.start = function(name) {
    this._recording = true;
    return this.current = this.runners.get(name).start();
  };

  /*
  */


  Recorder.prototype.stop = function() {
    this._recording = false;
    return this;
  };

  /*
  */


  Recorder.prototype.remove = function(name) {
    this.runners.remove(name);
    this._update();
    return this;
  };

  /*
  */


  Recorder.prototype.clear = function() {
    this.runners.clear();
    this._update();
    return this;
  };

  /*
  */


  Recorder.prototype._onEvent = function(event) {
    if (event.listener !== "dom" || this._recording !== true) {
      return;
    }
    console.log("%c %s %s", "color:#FF00FF;", event.type, event.data.xpath);
    this.current.actions.push(event);
    return this._update();
  };

  /*
  */


  Recorder.prototype._update = function() {
    return this.emit("update");
  };

  return Recorder;

})(events.EventEmitter);

module.exports = Recorder;

},{"./runners":12,"events":14}],10:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
var ActionRunner, type;

type = require("type-component");

ActionRunner = (function() {
  /*
  */

  function ActionRunner(runner, _action) {
    this.runner = runner;
    this._action = _action;
  }

  /*
  */


  ActionRunner.prototype.start = function(next) {
    var findElement, method, xpath;
    if (next == null) {
      next = function() {};
    }
    if (type(this._action) === "string") {
      return this.runner.runners.get(this._action).start(next);
    }
    method = this._action.type;
    xpath = this._action.data.xpath;
    console.log("%c %s %s", "color:#FF00FF;", method, xpath);
    findElement = function() {
      var $e;
      $e = $(document.body).xpath(xpath);
      if (!$e.length) {
        return setTimeout(findElement, 500);
      }
      $e[method].call($e);
      return next();
    };
    return findElement();
  };

  return ActionRunner;

})();

module.exports = ActionRunner;

},{"type-component":1}],11:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
var ActionRunner, GroupRunner, flatstack;

flatstack = require("flatstack");

ActionRunner = require("./action");

GroupRunner = (function() {
  /*
  */

  function GroupRunner(runners, name) {
    this.runners = runners;
    this.name = name;
    this.actions = [];
  }

  /*
  */


  GroupRunner.prototype.fromJSON = function(data) {
    this.actions = data.actions;
    this.description = data.description;
    return this.name = data.name;
  };

  /*
  */


  GroupRunner.prototype.toJSON = function() {
    return {
      actions: this.actions,
      description: this.description,
      name: name
    };
  };

  /*
  */


  GroupRunner.prototype.start = function(next) {
    var q;
    if (next == null) {
      next = function() {};
    }
    console.log("%c run %s", "color:#FF00FF;", this.name);
    q = flatstack();
    this.actions.forEach(function(action) {
      return q.push(function(next) {
        return new ActionRunner(this, action).start(next);
      });
    });
    q.push(function() {
      return next();
    });
    return this;
  };

  return GroupRunner;

})();

module.exports = GroupRunner;

},{"./action":10,"flatstack":16}],12:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
var ActionsRunner, Runners;

ActionsRunner = require("./actions");

Runners = (function() {
  /*
  */

  function Runners() {
    this.clear();
  }

  /*
  */


  Runners.prototype.get = function(name) {
    var _ref;
    return (_ref = this._runners[name]) != null ? _ref : (this._runners[name] = new ActionsRunner(this, name));
  };

  /*
  */


  Runners.prototype.remove = function(name) {
    return delete this._runners[ame];
  };

  /*
  */


  Runners.prototype.clear = function() {
    return this._runners = {};
  };

  /*
  */


  Runners.prototype.toJSON = function() {
    var data, name;
    data = {};
    for (name in this._runners) {
      data[name] = this._runners[name].toJSON();
    }
    return data;
  };

  /*
  */


  Runners.prototype.fromJSON = function(runners) {
    var name, r, _results;
    _results = [];
    for (name in runners) {
      this._runners[name] = r = new ActionsRunner(this, name);
      _results.push(r.fromJSON(runners[name]));
    }
    return _results;
  };

  return Runners;

})();

module.exports = Runners;

},{"./actions":11}],13:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
var Storage, store,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

store = require("store");

Storage = (function() {
  /*
  */

  function Storage(_recorder) {
    this._recorder = _recorder;
    this.save = __bind(this.save, this);
    this._load();
  }

  /*
  */


  Storage.prototype.save = function(name, callback) {
    return store.set("actions", this._recorder.runners.toJSON());
  };

  /*
  */


  Storage.prototype.autoSave = function() {
    return this._recorder.on("update", this.save);
  };

  /*
  */


  Storage.prototype._load = function(callback) {
    if (callback == null) {
      callback = function() {};
    }
    return this._recorder.runners.fromJSON(store.get("actions") || {});
  };

  return Storage;

})();

module.exports = Storage;

},{"store":17}],14:[function(require,module,exports){
var process=require("__browserify_process");if (!process.EventEmitter) process.EventEmitter = function () {};

var EventEmitter = exports.EventEmitter = process.EventEmitter;
var isArray = typeof Array.isArray === 'function'
    ? Array.isArray
    : function (xs) {
        return Object.prototype.toString.call(xs) === '[object Array]'
    }
;
function indexOf (xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for (var i = 0; i < xs.length; i++) {
        if (x === xs[i]) return i;
    }
    return -1;
}

// By default EventEmitters will print a warning if more than
// 10 listeners are added to it. This is a useful default which
// helps finding memory leaks.
//
// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
var defaultMaxListeners = 10;
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!this._events) this._events = {};
  this._events.maxListeners = n;
};


EventEmitter.prototype.emit = function(type) {
  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events || !this._events.error ||
        (isArray(this._events.error) && !this._events.error.length))
    {
      if (arguments[1] instanceof Error) {
        throw arguments[1]; // Unhandled 'error' event
      } else {
        throw new Error("Uncaught, unspecified 'error' event.");
      }
      return false;
    }
  }

  if (!this._events) return false;
  var handler = this._events[type];
  if (!handler) return false;

  if (typeof handler == 'function') {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        var args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
    return true;

  } else if (isArray(handler)) {
    var args = Array.prototype.slice.call(arguments, 1);

    var listeners = handler.slice();
    for (var i = 0, l = listeners.length; i < l; i++) {
      listeners[i].apply(this, args);
    }
    return true;

  } else {
    return false;
  }
};

// EventEmitter is defined in src/node_events.cc
// EventEmitter.prototype.emit() is also defined there.
EventEmitter.prototype.addListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('addListener only takes instances of Function');
  }

  if (!this._events) this._events = {};

  // To avoid recursion in the case that type == "newListeners"! Before
  // adding it to the listeners, first emit "newListeners".
  this.emit('newListener', type, listener);

  if (!this._events[type]) {
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  } else if (isArray(this._events[type])) {

    // Check for listener leak
    if (!this._events[type].warned) {
      var m;
      if (this._events.maxListeners !== undefined) {
        m = this._events.maxListeners;
      } else {
        m = defaultMaxListeners;
      }

      if (m && m > 0 && this._events[type].length > m) {
        this._events[type].warned = true;
        console.error('(node) warning: possible EventEmitter memory ' +
                      'leak detected. %d listeners added. ' +
                      'Use emitter.setMaxListeners() to increase limit.',
                      this._events[type].length);
        console.trace();
      }
    }

    // If we've already got an array, just append.
    this._events[type].push(listener);
  } else {
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  var self = this;
  self.on(type, function g() {
    self.removeListener(type, g);
    listener.apply(this, arguments);
  });

  return this;
};

EventEmitter.prototype.removeListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('removeListener only takes instances of Function');
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (!this._events || !this._events[type]) return this;

  var list = this._events[type];

  if (isArray(list)) {
    var i = indexOf(list, listener);
    if (i < 0) return this;
    list.splice(i, 1);
    if (list.length == 0)
      delete this._events[type];
  } else if (this._events[type] === listener) {
    delete this._events[type];
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  if (arguments.length === 0) {
    this._events = {};
    return this;
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (type && this._events && this._events[type]) this._events[type] = null;
  return this;
};

EventEmitter.prototype.listeners = function(type) {
  if (!this._events) this._events = {};
  if (!this._events[type]) this._events[type] = [];
  if (!isArray(this._events[type])) {
    this._events[type] = [this._events[type]];
  }
  return this._events[type];
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (typeof emitter._events[type] === 'function')
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

},{"__browserify_process":15}],15:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            if (ev.source === window && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],16:[function(require,module,exports){
var _asyncCount = 0;

function flatstack(options) {

  if(!options) {
    options = {};
  }

  var _context = options.context,
  _parent      = options.parent,
  _asyncLength = options.asyncLength || 1;


  var _queue = [], _error = function(err) {
  
  }

  var self = {

    /**
     */

    _parent: _parent,


    /**
     */

    _pauseCount: 0,

    /**
     */

    error: function(callback) {
      _error = callback;
    },

    /**
     */

    child: function(context) {
      return flatstack({
        context     : _context,
        parent      : _parent,
        asyncLength : _asyncLength
      });
    },

    /**
     */

    pause: function() {
      
      var p = self;

      while(p) {
        p._pauseCount++;
        p = p._parent;
      }

      return self;
    },

    /**
     */

    resume: function(err) {

      if(err) _error(err);

      //already resumed? ignore!
      if(!self._pauseCount || self._resuming) return self;

      self._resuming = true;


      //if the queued function called for .pause() and .resume()
      //maintain the async behavior by adding a timeout - it's expected!
      if(_asyncCount++ == flatstack.asyncLimit) {
        _asyncCount = 0;
        setTimeout(self._resume, 0, arguments);
      } else {
        self._resume(arguments);
      }

      return self;
    },

    /**
     */

    _resume: function(args) {
      var p = self;
      self._resuming = false;

      //first decrmeent the pause count
      while(p) {
        p._pauseCount--;
        p = p._parent;
      }

      p = self;


      //next, resume eveything
      while(p) {
        if(p._pauseCount) break;
        p.next(args);
        p = p._parent;
      }
    },

    /**
     */

    push: function() {
      _queue.push.apply(_queue, arguments);
      self._run();
      return self;
    },

    /**
     */

    unshift: function() {
      _queue.unshift.apply(_queue, arguments);
      self._run();
      return self;
    },

    /**
     */

    next: function() {

      var args = Array.prototype.slice.call(arguments[0] || [], 0);

      var fn, context, ops;

      while(_queue.length) {

        //paused? stop for now
        if(self._pauseCount) break;

        ops = _queue.shift();

        context = ops.context || _context;
        fn      = ops.fn      || ops;

        //argument provided? it's asynchronous
        //also check if the function is async - might be looking for
        //arguments
        if(fn.length === _asyncLength || fn.async) {
          args.unshift(self.pause().resume);
          fn.apply(context, args);
        } else {
          fn.apply(context, args);
        }
      }

      if(self._complete && !_queue.length && !self._pauseCount) {
        self._complete();

        //can ONLY be called once - dispose of this.
        self._complete = undefined;
      }

    },

    /**
     */

    complete: function(fn) {

      self._complete = fn;

      //just need to get to the ._complete() logic
      if(!_queue.length) return self.next();
    },

    /**
     */

    _run: function() {
      if(self._pauseCount || !_queue.length) return;
      self.next();
    }
  };

  return self;
}

flatstack.asyncLimit = 10;
module.exports = flatstack;
},{}],17:[function(require,module,exports){
;(function(){
	var store = {},
		win = window,
		doc = win.document,
		localStorageName = 'localStorage',
		namespace = '__storejs__',
		storage

	store.disabled = false
	store.set = function(key, value) {}
	store.get = function(key) {}
	store.remove = function(key) {}
	store.clear = function() {}
	store.transact = function(key, defaultVal, transactionFn) {
		var val = store.get(key)
		if (transactionFn == null) {
			transactionFn = defaultVal
			defaultVal = null
		}
		if (typeof val == 'undefined') { val = defaultVal || {} }
		transactionFn(val)
		store.set(key, val)
	}
	store.getAll = function() {}

	store.serialize = function(value) {
		return JSON.stringify(value)
	}
	store.deserialize = function(value) {
		if (typeof value != 'string') { return undefined }
		try { return JSON.parse(value) }
		catch(e) { return value || undefined }
	}

	// Functions to encapsulate questionable FireFox 3.6.13 behavior
	// when about.config::dom.storage.enabled === false
	// See https://github.com/marcuswestin/store.js/issues#issue/13
	function isLocalStorageNameSupported() {
		try { return (localStorageName in win && win[localStorageName]) }
		catch(err) { return false }
	}

	if (isLocalStorageNameSupported()) {
		storage = win[localStorageName]
		store.set = function(key, val) {
			if (val === undefined) { return store.remove(key) }
			storage.setItem(key, store.serialize(val))
			return val
		}
		store.get = function(key) { return store.deserialize(storage.getItem(key)) }
		store.remove = function(key) { storage.removeItem(key) }
		store.clear = function() { storage.clear() }
		store.getAll = function() {
			var ret = {}
			for (var i=0; i<storage.length; ++i) {
				var key = storage.key(i)
				ret[key] = store.get(key)
			}
			return ret
		}
	} else if (doc.documentElement.addBehavior) {
		var storageOwner,
			storageContainer
		// Since #userData storage applies only to specific paths, we need to
		// somehow link our data to a specific path.  We choose /favicon.ico
		// as a pretty safe option, since all browsers already make a request to
		// this URL anyway and being a 404 will not hurt us here.  We wrap an
		// iframe pointing to the favicon in an ActiveXObject(htmlfile) object
		// (see: http://msdn.microsoft.com/en-us/library/aa752574(v=VS.85).aspx)
		// since the iframe access rules appear to allow direct access and
		// manipulation of the document element, even for a 404 page.  This
		// document can be used instead of the current document (which would
		// have been limited to the current path) to perform #userData storage.
		try {
			storageContainer = new ActiveXObject('htmlfile')
			storageContainer.open()
			storageContainer.write('<s' + 'cript>document.w=window</s' + 'cript><iframe src="/favicon.ico"></iframe>')
			storageContainer.close()
			storageOwner = storageContainer.w.frames[0].document
			storage = storageOwner.createElement('div')
		} catch(e) {
			// somehow ActiveXObject instantiation failed (perhaps some special
			// security settings or otherwse), fall back to per-path storage
			storage = doc.createElement('div')
			storageOwner = doc.body
		}
		function withIEStorage(storeFunction) {
			return function() {
				var args = Array.prototype.slice.call(arguments, 0)
				args.unshift(storage)
				// See http://msdn.microsoft.com/en-us/library/ms531081(v=VS.85).aspx
				// and http://msdn.microsoft.com/en-us/library/ms531424(v=VS.85).aspx
				storageOwner.appendChild(storage)
				storage.addBehavior('#default#userData')
				storage.load(localStorageName)
				var result = storeFunction.apply(store, args)
				storageOwner.removeChild(storage)
				return result
			}
		}

		// In IE7, keys may not contain special chars. See all of https://github.com/marcuswestin/store.js/issues/40
		var forbiddenCharsRegex = new RegExp("[!\"#$%&'()*+,/\\\\:;<=>?@[\\]^`{|}~]", "g")
		function ieKeyFix(key) {
			return key.replace(forbiddenCharsRegex, '___')
		}
		store.set = withIEStorage(function(storage, key, val) {
			key = ieKeyFix(key)
			if (val === undefined) { return store.remove(key) }
			storage.setAttribute(key, store.serialize(val))
			storage.save(localStorageName)
			return val
		})
		store.get = withIEStorage(function(storage, key) {
			key = ieKeyFix(key)
			return store.deserialize(storage.getAttribute(key))
		})
		store.remove = withIEStorage(function(storage, key) {
			key = ieKeyFix(key)
			storage.removeAttribute(key)
			storage.save(localStorageName)
		})
		store.clear = withIEStorage(function(storage) {
			var attributes = storage.XMLDocument.documentElement.attributes
			storage.load(localStorageName)
			for (var i=0, attr; attr=attributes[i]; i++) {
				storage.removeAttribute(attr.name)
			}
			storage.save(localStorageName)
		})
		store.getAll = withIEStorage(function(storage) {
			var attributes = storage.XMLDocument.documentElement.attributes
			var ret = {}
			for (var i=0, attr; attr=attributes[i]; ++i) {
				var key = ieKeyFix(attr.name)
				ret[attr.name] = store.deserialize(storage.getAttribute(key))
			}
			return ret
		})
	}

	try {
		store.set(namespace, namespace)
		if (store.get(namespace) != namespace) { store.disabled = true }
		store.remove(namespace)
	} catch(e) {
		store.disabled = true
	}
	store.enabled = !store.disabled
	if (typeof module != 'undefined' && module.exports) { module.exports = store }
	else if (typeof define === 'function' && define.amd) { define(store) }
	else { this.store = store }
})();

},{}],18:[function(require,module,exports){
module.exports = function(item) {
  if(item === undefined)  return [];
  return Object.prototype.toString.call(item) === "[object Array]" ? item : [item];
}
},{}],19:[function(require,module,exports){
// Generated by CoffeeScript 1.4.0
(function() {

  module.exports = (function() {

    function _Class() {}

    /*
    */


    _Class.prototype.find = function(nodeName) {
      if (nodeName == null) {
        nodeName = "*";
      }
      return this._newChain("//" + nodeName);
    };

    /*
    */


    _Class.prototype.element = function(nodeName) {
      if (nodeName == null) {
        nodeName = "*";
      }
      return this._newChain("/" + nodeName);
    };

    /*
    */


    _Class.prototype.toString = function() {
      return "";
    };

    /*
    */


    _Class.prototype._newChain = function(nodeName) {};

    return _Class;

  })();

}).call(this);

},{}],20:[function(require,module,exports){
// Generated by CoffeeScript 1.4.0

/*
 stores registered element chains
*/


(function() {

  module.exports = (function() {
    /*
    */

    function _Class() {
      this._chains = {};
    }

    /*
    */


    _Class.prototype.add = function(key, chain) {
      return this._chains[key] = chain.clone();
    };

    /*
    */


    _Class.prototype.get = function(key) {
      if (!this._chains[key]) {
        throw new Error("chain " + key + " does not exist");
      }
      return this._chains[key];
    };

    return _Class;

  })();

}).call(this);

},{}],21:[function(require,module,exports){
// Generated by CoffeeScript 1.4.0
(function() {
  var ElementChain,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  module.exports = ElementChain = (function(_super) {

    __extends(ElementChain, _super);

    /*
    */


    function ElementChain(_nodeName, parent) {
      this._nodeName = _nodeName;
      this.parent = parent;
      this._search = [];
    }

    /*
    */


    ElementChain.prototype.toString = function() {
      var chain;
      chain = [this.parent.toString()];
      chain.push(this._nodeName);
      if (this._search.length) {
        chain.push("[" + (this._search.join(' ')) + "]");
      }
      if (this._index !== void 0) {
        chain.push("[" + this._index + "]");
      }
      return chain.join("");
    };

    /*
    */


    ElementChain.prototype.contains = function(name, value) {
      return this._addSearch("contains(" + name + ",'" + value + "')");
    };

    /*
    */


    ElementChain.prototype.eq = function(name, value) {
      return this.op(name, "=", value);
    };

    /*
    */


    ElementChain.prototype.neq = function(name, value) {
      return this.op(name, "!=", value);
    };

    /*
    */


    ElementChain.prototype.gt = function(name, value) {
      return this.op(name, ">", value);
    };

    /*
    */


    ElementChain.prototype.lt = function(name, value) {
      return this.op(name, "<", value);
    };

    /*
    */


    ElementChain.prototype.gte = function(name, value) {
      return this.op(name, ">=", value);
    };

    /*
    */


    ElementChain.prototype.lte = function(name, value) {
      return this.op(name, "<=", value);
    };

    /*
    */


    ElementChain.prototype.op = function(name, op, value) {
      return this._addSearch("" + name + op + "'" + value + "'");
    };

    /*
    */


    ElementChain.prototype.or = function() {
      return this._addSearch("or");
    };

    /*
    */


    ElementChain.prototype.and = function() {
      return this._addSearch("and");
    };

    /*
    */


    ElementChain.prototype.index = function(value) {
      this._index = value;
      return this;
    };

    /*
    */


    ElementChain.prototype.search = function(value) {
      this._search = [value];
      return this;
    };

    /*
       registers this chain to the
    */


    ElementChain.prototype.register = function(name) {
      this.root().register(name, this);
      return this;
    };

    /*
    */


    ElementChain.prototype.root = function() {
      var p;
      p = this.parent;
      while (p.parent) {
        p = p.parent;
      }
      return p;
    };

    /*
       clones this chain
    */


    ElementChain.prototype.clone = function() {
      var chain;
      chain = new ElementChain(this._nodeName, this.parent);
      chain._search = this._search.concat();
      chain._index = this._index;
      return chain;
    };

    /*
    */


    ElementChain.prototype._newChain = function(nodeName, parent) {
      return new ElementChain(nodeName, this);
    };

    /*
    */


    ElementChain.prototype._addSearch = function(search) {
      this._search.push(search);
      return this;
    };

    return ElementChain;

  })(require("./base"));

}).call(this);

},{"./base":19}],22:[function(require,module,exports){
// Generated by CoffeeScript 1.4.0
(function() {
  var Dictionary, ElementChain, XPGen,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  ElementChain = require("./elementChain");

  Dictionary = require("./dictionary");

  XPGen = (function(_super) {

    __extends(_Class, _super);

    /*
    */


    function _Class() {
      _Class.__super__.constructor.call(this);
      this._dictionary = new Dictionary();
    }

    /*
       DEPRECATED for path
    */


    _Class.prototype.chain = function(name) {
      return this.path(name);
    };

    /*
    */


    _Class.prototype.path = function(name) {
      return this._dictionary.get(name).clone();
    };

    /*
    */


    _Class.prototype.register = function(name, chain) {
      this._dictionary.add(name, chain);
      return this;
    };

    /*
    */


    _Class.prototype._newChain = function(nodeName) {
      return new ElementChain(nodeName, this);
    };

    return _Class;

  })(require("./base"));

  module.exports = function() {
    return new XPGen();
  };

}).call(this);

},{"./base":19,"./dictionary":20,"./elementChain":21}]},{},[2])
;